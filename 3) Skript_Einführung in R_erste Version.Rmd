---
title: "Skript_Einführung in R"
output: html_document
date: "2022-10-04"
---

########## Einführung in R ##########

```{r setup,}

# Rechenoperationen und Standardoperatoren:
 
1 + 1 # Addition
3 * 7 # Multiplikation

5 ^ 2 # Potenzieren
sqrt(25) # Quadratwurzel ziehen
log(32) # Logarithmieren (ln)
exp(3) # Exponieren (e^)

11 - 7 * (2 + 1) # Die üblichen Regeln gelten auch

1 < 2
1 >= 2

3 == 3 # Gleichheit
"R" == "schwierig" # Ist R schwierig?
3 != 7 # Ungleichheit

```

# Ermöglicht das Setzen von Kommentaren
...sehr sinnvoll um später die eigenen Gedankengänge noch irgendwie nachvollziehen zu können

```{r}

# Zuweisungen:

x <- 3 + 7 # Legt ein Objekt x in der Environment an und speichert den Wert/das Ergebnis darin

x # Aufrufen des Objektes x

x # R ist case sensitive --> Schreibweise beachten

y <- 11
z <- x * y

ls() # Zeigt eine Übersicht über die Inhalte der Environment

rm(z) # Löscht das Objekt z aus der Environment
rm(list=ls()) # Löscht alle Inhalte der Environment

.a <- 7 # Objekte, die mit einem Punkt beginnen, werden in der Environment nicht angezeigt
.a # ...können aber normal aufgerufen werden

```


```{r}

# Spezielle Konstanten:

b <- c(3, NA, 7, 11) # NA kennzeichnet Missings (fehlende/undefinierte Werte)
# Die Funktion c() erstellt einen Vektor...dazu aber gleich mehr...
is.na(b) # Mit is.na() lässt sich prüfen, ob Missings vorhanden sind

w <- NULL  # NULL liefert ein leeres Objekt (der Länge Null)
is.null(w)  # Prüft, ob NULL zutreffend oder nicht

is.finite(5/0) # Prüft auf Endlichkeit eines Wertes ...hier nicht zutreffend, da Division durch 0
is.finite(6/2)

0/0 # ...liefert das Ergebnis NaN ...bedeutet Not a Number und meint, dass das Ergebnis dieser Operation nicht vernünftig definierbar ist

```

Datentypen und Datenstrukturen:

```{r}

### Der Vektor ###

x <- c(1, 2, 2, 3, 1) # Wie schon geschrieben, erzeugen wir so einen Vektor
x <- c(1, 2, 3, 4, 5) # ...den wir ohne Warnung überschreiben können (so wie jedes andere Objekt, also VORSICHT bei der Objektbezeichung)

x * 2 # Jedes Element im Vektor wird mit 2 multipliziert
x + 2 # ...oder addiert

y <- c(5, 4, 3, 2, 1)
x + y

length(x) # Übersicht über die Anzahl der Elemente, die im Objekt gespeichert sind
class(x) # Auskunft über die Klasses des Objektes ...in diesem Fall numeric; aber auch character, logical (TRUE/FALSE), complex (komplexe Zahlen) und NULL (leere Menge) möglich
x1 <- c(1, 2, 3)
x2 <- c("a", "b", "c")
x3 <- c(TRUE, FALSE, TRUE)
x4 <- c(1, FALSE, TRUE) # FALSE steht für den Wert 0, TRUE für den Wert 1
x5 <- c(1, "b", TRUE) # Da b ein Buchstabe ist, der keinen Zahlenwert besitzt, werden die übrigen Werte der Klasse von b = Character zugeordnet --> kleinster gemeinsamer Nenner
str(x) # Gibt Auskunft über die Struktur des Objektes (Class, Anzahl der Elemente sowie die konkreten Elemente)

# ...es gibt aber auch noch andere Möglichkeiten, einen Vektor zu erzeugen:

x <- 1:10 # Erzeugt einen Vektor der Zahlenfolge 1 bis 10

```


```{r}

### AUFGABE ###
# Was ist die Klasse dieses Vektors?

```


```{r}

y <- seq(from = 1945, to = 2022, by = 5) # Erzeugt eine Sequenz, die in 5er-Schritten ansteigt

abc <- letters # Erzeugt einen Vektor, bestehend aus den Buchstaben des Alphabets

rep("a", 10) # Repliziert den Character a 10mal
rep(c(1,3), 10) # Repliziert den Vektor bestehend aus den Werten 1 und 3 10mal

```


```{r}

### AUFGABE ###
rep(7:9, 1:3) 
# Was passiert hier?

```


```{r}

paste("x", 1:6) # Elemente werden miteinander verbunden

```


```{r}

# Indizierung eines Vektors:

abc[1] # []-Operator für Subsetting...in diesem Fall erstes Element im Vektor abc

```


```{r}

### AUFGABE ###
# Subsette aus dem Vektor abc die Buchstaben a, c und x, y, z.

# Subsetting des Vektors
subset_abc <- abc[abc %in% c("a", "c", "x", "y", "z")]

# Ausgabe des subset Vektors
print(subset_abc)
```


```{r}

Geschlecht <- c("m", "w", "m", "m", "w", "m")

# Welche Elemente sind männlich?
which(Geschlecht == "m")

##### --> Elemente auf die zugegriffen werden kann, können auch verändert werden #####

abc[1] # Bisher ist der erste Eintrag im Alphabet a
abc[1] <- "z" # ...das ändern wir jetzt 

Jahreszahlen <- 1945:2022
Jahreszahlen_Ab2010 <- Jahreszahlen[Jahreszahlen > 2010] # Erzeugt einen neuen Vektor aus den gesubsetteten Jahreszahlen

Geschlecht_neu <- c("m", "w", "m", "n", "m", "w", "m", "n")

```


```{r}

### AUFGABE ###
# Ändere den Wert "n" (neutral) in die Bezeichnung "d" (divers).

# Beispielvektor
values <- c("m", "n", "f", "n", "m")

# Ändern von "n" zu "d"
values <- gsub("n", "d", values)

# Ausgabe des geänderten Vektors
print(values)

```


```{r}

# ...und weil wir sie schon vermisst haben: 

### Die Matrix ###

x1 <- 1:5 
x2 <- 6:10
x3 <- 11:15
x4 <- 16:20 # Vier Vektoren gleicher Länge

# ...die wir nun zu einer Matrix verbinden:
cbind(x1, x2, x3, x4) # Verbindet die Vektoren spaltenweise
rbind(x1, x2, x3, x4) # Verbindet die Vektoren zeilenweise

###### --> Eine Matrix wird wie ein Vektor, nur einem Datentyp zugeordnet ######

# Eine weitere Möglichkeit der Matrixkonstruktion:

Matrix1 <- matrix(1:20, nrow=5, ncol=4)
Matrix2 <- matrix(1:20, nrow=5, ncol=4, byrow = TRUE) # Was passiert jetzt?

nrow(Matrix1) # Anzahl der Zeilen
ncol(Matrix1) # Anzahl der Spalten
dim(Matrix1) # Zeigt die Werte zu beiden Dimensionen an

```


```{r}

# Indizierung einer Matrix:

Matrix1[1,1] # Zeigt das Element der ersten Zeile und der ersten Spalte 
Matrix1[3,4] # Zeigt das Element der dritten Zeile und der vierten Spalte

Matrix1[3, ] # Zeigt alle Elemente der dritten Zeile
Matrix1[, 4] # Zeigt alle Elemente der vierten Spalte

```


```{r}

### AUFGABE ###
# Zeige die Elemente der ersten bis dritten Zeile in der vierten Spalte

```


```{r}

# ...und wenn wir eine Matrix transponieren müssen; P

Matrix3 <- t(Matrix1)

```


```{r}

### ...wenn wir nun aber unterschiedliche Datentypen in unserem Datensatz benötigen? 

### Dataframes ###

###### Die Datensätze, mit denen wir üblicherweise arbeiten, sind Dataframes, da sie heterogene Daten mit n Zeilen (Anzahl der Fälle) und k Spalten (Anzahl der Variablen) erlauben ######

ID <- 1:6
Alter <- c(18, 24, 33, 37, 50, 65)
Geschlecht <- c("m", "w", "w", "m", "w", "w")  
Gesundheit <- c(1, 2, 1, 1, 2, 3)  # Einschätzung der eigenen Gesundheit auf einer Skala von 1 (gut) bis 3 (schlecht)
Gesundheitsvorsorge <- c(FALSE, FALSE, TRUE, FALSE, TRUE, TRUE)

Unser_erster_Datensatz <- data.frame(ID, Alter, Geschlecht, Gesundheit, Gesundheitsvorsorge)

summary(Unser_erster_Datensatz)  # Zentrale statistische Parameter zu den einzelnen Variablen
Unser_erster_Datensatz  # Sehen wir uns den Datensatz mal komplett an

```


```{r}

# Indizierung eines Dataframes:

Unser_erster_Datensatz[, 2] # Funktioniert wie bei einer Matrix und zeigt in diesem Fall alle Werte der zweiten Spalte (Alter)

# ...es gibt aber auch einen anderen Weg:
Unser_erster_Datensatz$Alter
Unser_erster_Datensatz$Alter[3] # Zeigt den dritten Wert (zum dritten Probanden) aus der Variable Alter

mean(Unser_erster_Datensatz$Alter) # ...und mit den Werten können wir auch gleich ein bisschen rechnen
table(Unser_erster_Datensatz$Geschlecht) # ...oder tabellarisch aufbereitet anzeigen lassen
Unser_erster_Datensatz$Alter[Unser_erster_Datensatz$Geschlecht == "w"] # ...und uns nur das Alter der Frauen im Datensatz anzeigen lassen
mean(Unser_erster_Datensatz$Alter[Unser_erster_Datensatz$Geschlecht == "w"]) # ...die Möglichkeiten sind einfach unbegrenzt xD

```


```{r}

### AUFGABE ###

# Das war jetzt aber viel...was lagert nun alles in unserer Environment?

  
# ...wow, das ist echt viel...und wir benötigen aktuell nichts davon, daher räumen wir jetzt mal auf

```

RMarkdown anlegen:

```{r}

### --> File --> New File --> RMarkdown --> Titel geben, ggf. Autor festlegen und Ausgabeformat

```

